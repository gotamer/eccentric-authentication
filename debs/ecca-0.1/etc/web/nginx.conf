## nginx.conf for ecca CA signing server

user  nobody;
worker_processes  1;

error_log logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

pid  nginx.pid;


events {
    worker_connections  1024;
}

## These are the CA certificate and Private key that are needed by 
## the register-*.lua scripts.
env CACERT=/etc/ecca/subCA/subcacert.pem;
env CAKEY=/etc/ecca/subCA/private/subcakey.pem;


http {
    include       /usr/share/ecca/web/mime.types;
    default_type  text/html;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    log_format  ssl_log  '$remote_addr - $remote_user "$request" '
                         '$status $body_bytes_sent '
                         '$ssl_client_verify "$ssl_client_i_dn" "$ssl_client_s_dn" "$ssl_client_serial"';

    access_log   logs/ssl_log  ssl_log;
    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    ## The memcacheDB stores the certificates for each CN.
    ## Notice, it's a memcacheDB, ie permanent storage in BerkeleyDB files. (Not memcached, a transient cache)
    upstream memcacheDB_cn {
        server 127.0.0.1:21202;
	keepalive 32;
    }

    # HTTPS server
    # Runs the open pages, ie, accessible to anyone.
    server {
        listen               7444;
	keepalive_timeout    70;
        server_name   	     localhost;

        ssl                  on;
	## these are the server certificate and key for the https protocol
        ssl_certificate      /etc/ecca/web/ecca-server-cert.pem;
        ssl_certificate_key  /etc/ecca/web/ecca-server-key.pem;

        ssl_session_timeout  10m;
	ssl_session_cache    shared:SSL:10m;

        ssl_protocols        SSLv3 TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers          HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers   off;

	## we set to optional so we can allow some pages non-authenticated (help pages and errors)
	## at time of first registration client has no cert.
	## for renewals of (almost) expired certs we do need a certificate
	## TODO: built this renewal service
	ssl_verify_client      optional;

	lua_code_cache on;

        location / {
	    ## show welcome page and link to CA to register
	    root  /usr/share/ecca/web/htdocs;
	    index index.html;
        }


	## perform registration with a CSR containing a CN and Pubkey
	location /register-csr {
	    limit_except POST { allow all; }
	    content_by_lua_file ../register-csr.lua;
	}

	## perform registration with a CN and Pubkey
	location /register-pubkey {
	    limit_except POST { allow all; }
	    content_by_lua_file ../register-pubkey.lua;
	}

	## perform registration with a Netscape/Firefox SPKAC
	location /register-spkac {
	    limit_except POST { allow all; }
	    content_by_lua_file ../register-spkac.lua;
	}

	## Allow everyone to query the CN->certificate mappings.
	## Make sure it's read only or we allow people to write to our memcacheDB!
	location /check-nickname-available {
	    limit_except GET { allow all; }
	    echo_exec /memcacheDB-cn?cmd=get&key=$arg_nickname;
  	}

	## This queries the CN->certificate datastore.
	## It allows all memcache-methods (get, set, add, delete, flush) so keep it internal!
	location /memcacheDB-cn {
	    internal;
    	    set  $memc_key  $arg_key;
    	    memc_pass memcacheDB_cn;
	}
    }
    
}
